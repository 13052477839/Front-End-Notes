#异步I／O

异步编程一般不是其他语言的主要编程方式，尤其PHP，因为:`设计者认为程序员不适合通过异步来进行程序设计`
* Nginx与Node的设计理念相近！

## 为什么是异步I／O
并发是现代编程中的标准配备！两个方面：
* 用户体验
* 资源分配

### 用户体验

首先，前端中通过异步消除了UI阻塞的现象。
但是，前端中获取资源取决于后台响应的速度，如果并发响应的话，明显可以减少时间。
而且，采用分布式之后效果更佳明显。

### 资源分配
有两个方法解决执行多组不相关任务：
* 多线程并行，在多核CPU上横过有效提升CPU利用率。
但是多线程的代价在于创建线程和执行期间的上下文切换的开销较大，并且要面领锁，状态同步等问题。

* 单线程顺序执行。会因为阻塞I／O导致硬件资源得不到更优的使用。

`Node的方案：`
* 利用单线程，远离多线程死锁，状态同步的问题。
* 利用异步I／O，让单线程远离阻塞。

![异步I／O调用]()


## 异步I／O实现现状

### 异步I／O和非阻塞I／O

异步和阻塞是不同的概念。

内核对于I/O只有两种方式：阻塞和非阻塞。
* 阻塞I／O的特点：等到系统内核层面完成所有操作后，调用才结束（例如磁盘寻道，读取数据，复制数组道内存中）。会造成CPU等待I/O。
* 非阻塞I/O：会立刻返回，CPU的时间片可以处理其它事务，但是完整的I／O还没有完成，所以返回的并不是业务层期望的数据，而仅是当前调用的状态。

为了获得完整的数据需要通过重复调用I／O来确认是否完成，即`轮询`。但是任何技术都不是完美的。轮询会让CPU处理状态判断，是对CPU的资源浪费。
轮询的发展流程：
* read
* select
* poll
* epoll: LInux最高效的I/O事件通知机制。利用了事件通知，执行回调的方式，而不是遍历查询。没有检查到I/O事件将会进入休眠。

### 现实中的异步I/O
* 通过部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取。让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递。
libeio：采用线程池与阻塞I/O模拟异步I/O。

* Windows下的IOCP：无须轮询，等待I／O完成之后通知。仍然是使用线程池原理，不同之处是线程池由系统内核接手管理。

Node中的libuv座位抽象封装层，使得所有平台兼容性的判断都由这层来完成。

## Node的异步I／O

### 事件循环
Node的自身执行模型：事件循环。
在进程启动时，Node会创建一个Tick。每个Tick的过程就是查看是否有事件待处理，如果有就去处事件及其相关的回调。
![Tick流程图]()

###观察者
Tick过程如何知道有事件需要处理？
